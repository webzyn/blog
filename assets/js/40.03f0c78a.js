(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{311:function(_,t,v){"use strict";v.r(t);var s=v(13),a=Object(s.a)({},(function(){var _=this,t=_._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"_1"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1"}},[_._v("#")]),_._v(" 1")]),_._v(" "),t("h2",{attrs:{id:"js"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#js"}},[_._v("#")]),_._v(" js")]),_._v(" "),t("h3",{attrs:{id:"_1-如何理解-js-的异步"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-如何理解-js-的异步"}},[_._v("#")]),_._v(" 1. 如何理解 JS 的异步？")]),_._v(" "),t("p",[_._v("参考答案：")]),_._v(" "),t("ul",[t("li",[_._v("JS 是⼀⻔单线程的语⾔，这是因为它运⾏在浏览器的渲染主线程中，⽽渲染\n主线程只有⼀个。")]),_._v(" "),t("li",[_._v("⽽渲染主线程承担着诸多的⼯作，渲染⻚⾯、执⾏ JS 都在其中运⾏。")]),_._v(" "),t("li",[_._v("如果使⽤同步的⽅式，就极有可能导致主线程产⽣阻塞，从⽽导致消息队列\n中的很多其他任务⽆法得到执⾏。")]),_._v(" "),t("li",[_._v("这样⼀来，⼀⽅⾯会导致繁忙的主线程⽩\n⽩的消耗时间，另⼀⽅⾯导致⻚⾯⽆法及时更新，给⽤户造成卡死现象。")]),_._v(" "),t("li",[_._v("所以浏览器采⽤异步的⽅式来避免。具体做法是当某些任务发⽣时，⽐如计\n时器、⽹络、事件监听，主线程将任务交给其他线程去处理，⾃身⽴即结束\n任务的执⾏，转⽽执⾏后续代码。")]),_._v(" "),t("li",[_._v("当其他线程完成时，将事先传递的回调函\n数包装成任务，加⼊到消息队列的末尾排队，等待主线程调度执⾏。")]),_._v(" "),t("li",[_._v("在这种异步模式下，浏览器永不阻塞，从⽽最⼤限度的保证了单线程的流畅\n运⾏。")])]),_._v(" "),t("h3",{attrs:{id:"_2-阐述一下-js-的事件循环"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-阐述一下-js-的事件循环"}},[_._v("#")]),_._v(" 2. 阐述⼀下 JS 的事件循环")]),_._v(" "),t("p",[_._v("参考答案：")]),_._v(" "),t("ul",[t("li",[_._v("事件循环⼜叫做消息循环，是浏览器渲染主线程的⼯作⽅式。")]),_._v(" "),t("li",[_._v("在 Chrome 的源码中，它开启⼀个不会结束的 for 循环，每次循环从消息\n队列中取出第⼀个任务执⾏，⽽其他线程只需要在合适的时候将任务加⼊到\n队列末尾即可。")]),_._v(" "),t("li",[_._v("过去把消息队列简单分为宏队列和微队列，这种说法⽬前已⽆法满⾜复杂的\n浏览器环境，取⽽代之的是⼀种更加灵活多变的处理⽅式。")]),_._v(" "),t("li",[_._v("根据 W3C 官⽅的解释，每个任务有不同的类型，同类型的任务必须在同⼀\n个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，\n在⼀次事件循环中，由浏览器⾃⾏决定取哪⼀个队列的任务。但浏览器必须\n有⼀个微队列，微队列的任务⼀定具有最⾼的优先级，必须优先调度执⾏。")])]),_._v(" "),t("h3",{attrs:{id:"_3-js-中的计时器能做到精确计时吗-为什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-js-中的计时器能做到精确计时吗-为什么"}},[_._v("#")]),_._v(" 3. JS 中的计时器能做到精确计时吗？为什么？")]),_._v(" "),t("p",[_._v("参考答案：\n不⾏，因为：")]),_._v(" "),t("ul",[t("li",[t("ol",[t("li",[_._v("计算机硬件没有原⼦钟，⽆法做到精确计时")])])]),_._v(" "),t("li",[t("ol",{attrs:{start:"2"}},[t("li",[_._v("操作系统的计时函数本身就有少量偏差，由于 JS 的计时器最终调⽤的\n是操作系统的函数，也就携带了这些偏差")])])]),_._v(" "),t("li",[t("ol",{attrs:{start:"3"}},[t("li",[_._v("按照 W3C 的标准，浏览器实现计时器时，如果嵌套层级超过 5 层，\n则会带有 4 毫秒的最少时间，这样在计时时间少于 4 毫秒时⼜带来\n了偏差")])])]),_._v(" "),t("li",[t("ol",{attrs:{start:"4"}},[t("li",[_._v("受事件循环的影响，计时器的回调函数只能在主线程空闲时运⾏，因此\n⼜带来了偏差")])])])]),_._v(" "),t("h2",{attrs:{id:"小程序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#小程序"}},[_._v("#")]),_._v(" 小程序")]),_._v(" "),t("h3",{attrs:{id:"_1-小程序启动过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-小程序启动过程"}},[_._v("#")]),_._v(" 1.小程序启动过程")]),_._v(" "),t("ul",[t("li",[_._v("① 把小程序的代码包下载到本地")]),_._v(" "),t("li",[_._v("② 解析 app.json 全局配置文件")]),_._v(" "),t("li",[_._v("③ 执行 app.js 小程序入口文件，"),t("span",{staticStyle:{color:"red"}},[_._v("调用 App()创建小程序实例")])]),_._v(" "),t("li",[_._v("④ 渲染小程序首页")]),_._v(" "),t("li",[_._v("⑤ 小程序启动完成")])]),_._v(" "),t("h3",{attrs:{id:"_2-页面渲染的过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-页面渲染的过程"}},[_._v("#")]),_._v(" 2.页面渲染的过程")]),_._v(" "),t("ul",[t("li",[_._v("① 加载解析页面的.json 配置文件")]),_._v(" "),t("li",[_._v("② 加载页面的.wxml 模板和.wxss 样式")]),_._v(" "),t("li",[_._v("③ 执行页面的.js 文件，"),t("span",{staticStyle:{color:"red"}},[_._v("调用 Page()创建页面实例")])]),_._v(" "),t("li",[_._v("④ 页面渲染完成")])])])}),[],!1,null,null,null);t.default=a.exports}}]);